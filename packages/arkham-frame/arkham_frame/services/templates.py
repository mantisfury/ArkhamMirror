"""
Template Service - Jinja2 template management for reports and documents.

Provides template registration, rendering, and management for
generating formatted documents and reports.
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

logger = logging.getLogger(__name__)

# Try to import Jinja2, provide fallback if not available
try:
    from jinja2 import Environment, FileSystemLoader, BaseLoader, TemplateNotFound
    from jinja2 import select_autoescape
    JINJA2_AVAILABLE = True
except ImportError:
    JINJA2_AVAILABLE = False
    logger.warning("Jinja2 not installed - template service will use basic string formatting")


# ============================================
# Exceptions
# ============================================

class TemplateError(Exception):
    """Base exception for template errors."""
    pass


class TemplateNotFoundError(TemplateError):
    """Template not found."""
    pass


class TemplateRenderError(TemplateError):
    """Error during template rendering."""
    pass


class TemplateSyntaxError(TemplateError):
    """Template syntax error."""
    pass


# ============================================
# Types
# ============================================

@dataclass
class Template:
    """Template definition."""
    name: str
    content: str
    description: str = ""
    category: str = "general"
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    variables: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class RenderResult:
    """Result of template rendering."""
    content: str
    template_name: str
    rendered_at: datetime = field(default_factory=datetime.utcnow)
    variables_used: Dict[str, Any] = field(default_factory=dict)


# ============================================
# String Loader for in-memory templates
# ============================================

if JINJA2_AVAILABLE:
    class DictLoader(BaseLoader):
        """Jinja2 loader that loads templates from a dictionary."""

        def __init__(self, templates: Dict[str, str]):
            self.templates = templates

        def get_source(self, environment, template):
            if template not in self.templates:
                raise TemplateNotFound(template)
            source = self.templates[template]
            return source, template, lambda: True


# ============================================
# Template Service
# ============================================

class TemplateService:
    """
    Service for managing and rendering Jinja2 templates.

    Provides:
    - Template registration and management
    - File-based and in-memory templates
    - Default report templates
    - Variable extraction
    """

    # Default templates for common use cases
    DEFAULT_TEMPLATES = {
        "report_basic": """# {{ title }}

**Generated:** {{ generated_at }}
{% if author %}**Author:** {{ author }}{% endif %}

---

{{ content }}

---
*Generated by ArkhamMirror*
""",
        "document_summary": """## Document Summary: {{ document.title }}

**ID:** {{ document.id }}
**Status:** {{ document.status }}
**Created:** {{ document.created_at }}

### Content
{{ document.content[:500] }}{% if document.content|length > 500 %}...{% endif %}

### Entities
{% for entity in entities %}
- {{ entity.name }} ({{ entity.type }})
{% endfor %}
""",
        "entity_report": """# Entity Report: {{ entity.name }}

**Type:** {{ entity.type }}
**Canonical:** {{ entity.is_canonical }}

## Mentions
{% for mention in mentions %}
- {{ mention.document_title }}: {{ mention.context }}
{% endfor %}

## Relationships
{% for rel in relationships %}
- {{ rel.type }}: {{ rel.target_name }}
{% endfor %}
""",
        "analysis_report": """# Analysis Report

**Project:** {{ project.name }}
**Date:** {{ date }}
**Analyst:** {{ analyst }}

## Executive Summary
{{ summary }}

## Key Findings
{% for finding in findings %}
### {{ finding.title }}
{{ finding.description }}
**Confidence:** {{ finding.confidence }}
{% endfor %}

## Recommendations
{% for rec in recommendations %}
{{ loop.index }}. {{ rec }}
{% endfor %}

---
*This report was generated automatically and should be reviewed by a human analyst.*
""",
        "email_notification": """Subject: {{ subject }}

{{ greeting }},

{{ body }}

{% if action_required %}
**Action Required:** {{ action_required }}
{% endif %}

Best regards,
{{ sender }}
""",
    }

    def __init__(
        self,
        template_dir: Optional[Union[str, Path]] = None,
        auto_reload: bool = True,
    ):
        """
        Initialize the template service.

        Args:
            template_dir: Optional directory for file-based templates
            auto_reload: Auto-reload templates from disk (dev mode)
        """
        self._template_dir = Path(template_dir) if template_dir else None
        self._templates: Dict[str, Template] = {}
        self._jinja_env = None

        # Initialize Jinja2 if available
        if JINJA2_AVAILABLE:
            loaders = []

            if self._template_dir and self._template_dir.exists():
                loaders.append(FileSystemLoader(str(self._template_dir)))

            # Create environment
            self._jinja_env = Environment(
                loader=DictLoader({}),  # Will be updated
                autoescape=select_autoescape(['html', 'xml']),
                auto_reload=auto_reload,
            )

            # Add custom filters
            self._jinja_env.filters['datetime'] = self._format_datetime
            self._jinja_env.filters['truncate_words'] = self._truncate_words

        # Register default templates
        for name, content in self.DEFAULT_TEMPLATES.items():
            self.register(name, content, category="default")

        logger.info(f"TemplateService initialized with {len(self._templates)} templates")

    @staticmethod
    def _format_datetime(value: datetime, format: str = "%Y-%m-%d %H:%M") -> str:
        """Format datetime for templates."""
        if isinstance(value, datetime):
            return value.strftime(format)
        return str(value)

    @staticmethod
    def _truncate_words(value: str, length: int = 50) -> str:
        """Truncate text to word boundary."""
        words = value.split()
        if len(words) <= length:
            return value
        return " ".join(words[:length]) + "..."

    def register(
        self,
        name: str,
        content: str,
        description: str = "",
        category: str = "general",
        variables: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Template:
        """
        Register a new template.

        Args:
            name: Template name (unique identifier)
            content: Template content (Jinja2 syntax)
            description: Human-readable description
            category: Template category for organization
            variables: List of expected variables
            metadata: Additional metadata

        Returns:
            Created Template object
        """
        # Auto-extract variables if not provided
        if variables is None:
            variables = self._extract_variables(content)

        template = Template(
            name=name,
            content=content,
            description=description,
            category=category,
            variables=variables,
            metadata=metadata or {},
        )

        self._templates[name] = template

        # Update Jinja2 loader
        if JINJA2_AVAILABLE and self._jinja_env:
            templates_dict = {t.name: t.content for t in self._templates.values()}
            self._jinja_env.loader = DictLoader(templates_dict)

        logger.debug(f"Registered template: {name}")
        return template

    def get(self, name: str) -> Optional[Template]:
        """
        Get a template by name.

        Args:
            name: Template name

        Returns:
            Template object or None
        """
        return self._templates.get(name)

    def list(
        self,
        category: Optional[str] = None,
    ) -> List[Template]:
        """
        List all templates.

        Args:
            category: Optional category filter

        Returns:
            List of Template objects
        """
        templates = list(self._templates.values())

        if category:
            templates = [t for t in templates if t.category == category]

        return sorted(templates, key=lambda t: t.name)

    def delete(self, name: str) -> bool:
        """
        Delete a template.

        Args:
            name: Template name

        Returns:
            True if deleted, False if not found
        """
        if name in self._templates:
            del self._templates[name]
            logger.debug(f"Deleted template: {name}")
            return True
        return False

    def render(
        self,
        name: str,
        variables: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> RenderResult:
        """
        Render a template with variables.

        Args:
            name: Template name
            variables: Variables to pass to template
            **kwargs: Additional variables

        Returns:
            RenderResult with rendered content

        Raises:
            TemplateNotFoundError: If template not found
            TemplateRenderError: If rendering fails
        """
        template = self._templates.get(name)
        if not template:
            raise TemplateNotFoundError(f"Template not found: {name}")

        # Merge variables
        all_vars = {
            "now": datetime.utcnow(),
            "generated_at": datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S"),
        }
        if variables:
            all_vars.update(variables)
        all_vars.update(kwargs)

        try:
            if JINJA2_AVAILABLE and self._jinja_env:
                jinja_template = self._jinja_env.get_template(name)
                content = jinja_template.render(**all_vars)
            else:
                # Fallback to basic string formatting
                content = self._basic_render(template.content, all_vars)

            return RenderResult(
                content=content,
                template_name=name,
                variables_used=all_vars,
            )

        except Exception as e:
            logger.error(f"Template render failed: {e}")
            raise TemplateRenderError(f"Failed to render template {name}: {e}") from e

    def render_string(
        self,
        content: str,
        variables: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> str:
        """
        Render a template string directly (without registering).

        Args:
            content: Template content
            variables: Variables for rendering
            **kwargs: Additional variables

        Returns:
            Rendered string
        """
        all_vars = {"now": datetime.utcnow()}
        if variables:
            all_vars.update(variables)
        all_vars.update(kwargs)

        try:
            if JINJA2_AVAILABLE and self._jinja_env:
                jinja_template = self._jinja_env.from_string(content)
                return jinja_template.render(**all_vars)
            else:
                return self._basic_render(content, all_vars)

        except Exception as e:
            logger.error(f"Template string render failed: {e}")
            raise TemplateRenderError(f"Failed to render template string: {e}") from e

    def _basic_render(self, content: str, variables: Dict[str, Any]) -> str:
        """
        Basic template rendering without Jinja2.

        Supports simple {{ variable }} substitution.
        """
        result = content

        for key, value in variables.items():
            placeholder = "{{ " + key + " }}"
            result = result.replace(placeholder, str(value))
            # Also handle without spaces
            placeholder = "{{" + key + "}}"
            result = result.replace(placeholder, str(value))

        return result

    def _extract_variables(self, content: str) -> List[str]:
        """
        Extract variable names from template content.

        Args:
            content: Template content

        Returns:
            List of variable names
        """
        import re
        # Match {{ variable }} and {{ variable.attr }}
        pattern = r'\{\{\s*([a-zA-Z_][a-zA-Z0-9_\.]*)'
        matches = re.findall(pattern, content)
        # Get unique root variable names
        variables = set()
        for match in matches:
            root = match.split('.')[0]
            variables.add(root)
        return sorted(variables)

    def get_categories(self) -> List[str]:
        """Get list of all template categories."""
        categories = set(t.category for t in self._templates.values())
        return sorted(categories)

    def validate(self, content: str) -> List[str]:
        """
        Validate template syntax.

        Args:
            content: Template content to validate

        Returns:
            List of error messages (empty if valid)
        """
        errors = []

        if JINJA2_AVAILABLE and self._jinja_env:
            try:
                self._jinja_env.parse(content)
            except Exception as e:
                errors.append(str(e))
        else:
            # Basic validation
            import re
            # Check for unmatched braces
            opens = len(re.findall(r'\{\{', content))
            closes = len(re.findall(r'\}\}', content))
            if opens != closes:
                errors.append(f"Unmatched braces: {opens} opens, {closes} closes")

        return errors

    def load_from_directory(self, directory: Union[str, Path]) -> int:
        """
        Load templates from a directory.

        Args:
            directory: Directory containing .j2, .jinja2, or .html files

        Returns:
            Number of templates loaded
        """
        directory = Path(directory)
        if not directory.exists():
            logger.warning(f"Template directory not found: {directory}")
            return 0

        count = 0
        extensions = ['.j2', '.jinja2', '.html', '.md', '.txt']

        for file_path in directory.iterdir():
            if file_path.suffix.lower() in extensions:
                try:
                    content = file_path.read_text(encoding='utf-8')
                    name = file_path.stem
                    self.register(
                        name=name,
                        content=content,
                        category="file",
                        metadata={"source": str(file_path)},
                    )
                    count += 1
                except Exception as e:
                    logger.warning(f"Failed to load template {file_path}: {e}")

        logger.info(f"Loaded {count} templates from {directory}")
        return count
